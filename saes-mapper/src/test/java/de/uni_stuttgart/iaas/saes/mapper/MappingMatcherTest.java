/*
* This file is part of the Serverless Application Extraction System (SAES)
*
* The Serverless Application Extraction System is licensed under under
* the Apache License, Version 2.0. Please see the included COPYING file
* for license information.
*/
package de.uni_stuttgart.iaas.saes.mapper;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import de.uni_stuttgart.iaas.saes.common.facts.Fact;
import de.uni_stuttgart.iaas.saes.common.facts.OriginArtifact;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.JSONPathAccessor;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.LookupFilter;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.Mapping;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.PropertyConstant;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.RegexFilter;
import de.uni_stuttgart.iaas.saes.knowledge_base.domain.TargetProperty;

/**
 * test cases generated by testing random strings of the alphabet [abc] against
 * random patterns from the alphabet [abc?*] in a <strong>different
 * implementation</strong>, namely the glob matching of GNU bash
 */
class MappingMatcherTest {

	private MappingMatcher m;
	private Fact fact1;
	private Mapping mapping1;
	private Mapping mapping2;

	@BeforeEach
	void setUp() {
		m = new MappingMatcher();
		fact1 = new Fact(//
				"gcloud/functions/eventtrigger", //
				new OriginArtifact(//
						"gcloud", //
						null, //
						"function1"//
				), //
				Map.of(//
						"resource", "A", //
						"event", "storage.object.bucket.finalize"//
				)//
		);
		mapping1 = new Mapping(//
				Map.of("type", "gcloud/functions/eventtrigger"), //
				"case/eventsource", //
				List.of(//
						new TargetProperty(//
								"event", //
								new LookupFilter(//
										"gcloud-events", //
										new JSONPathAccessor("$.eventTrigger.event")//
								)//
						)//
				)//
		);
		mapping2 = new Mapping(//
				Map.of("type", "some/example/type"), //
				"case/directcall", //
				List.of(//
						new TargetProperty(//
								"key", //
								new RegexFilter(//
										"a", //
										"b", //
										new PropertyConstant("a")//
								)//
						)//
				)//
		);
	}

	@Test
	void testWildcardPositive() {
		assertTrue(m.matchWildcard("a*", "acbab"), "wildcard a* should match haystack acbab");
		assertTrue(m.matchWildcard("*?*", "aac"), "wildcard *?* should match haystack aac");
		assertTrue(m.matchWildcard("*a", "a"), "wildcard *a should match haystack a");
		assertTrue(m.matchWildcard("a", "a"), "wildcard a should match haystack a");
		assertTrue(m.matchWildcard("a", "a"), "wildcard a should match haystack a");
		assertTrue(m.matchWildcard("*", "aa"), "wildcard * should match haystack aa");
		assertTrue(m.matchWildcard("?*", "abab"), "wildcard ?* should match haystack abab");
		assertTrue(m.matchWildcard("*?", "aba"), "wildcard *? should match haystack aba");
		assertTrue(m.matchWildcard("*???", "aba"), "wildcard *??? should match haystack aba");
		assertTrue(m.matchWildcard("*", "ab"), "wildcard * should match haystack ab");
		assertTrue(m.matchWildcard("*", "ab"), "wildcard * should match haystack ab");
		assertTrue(m.matchWildcard("??", "ab"), "wildcard ?? should match haystack ab");
		assertTrue(m.matchWildcard("*", "acba"), "wildcard * should match haystack acba");
		assertTrue(m.matchWildcard("*?", "a"), "wildcard *? should match haystack a");
		assertTrue(m.matchWildcard("*ba", "aaba"), "wildcard *ba should match haystack aaba");
		assertTrue(m.matchWildcard("*b", "aacbb"), "wildcard *b should match haystack aacbb");
		assertTrue(m.matchWildcard("*?", "babcb"), "wildcard *? should match haystack babcb");
		assertTrue(m.matchWildcard("*", "ba"), "wildcard * should match haystack ba");
		assertTrue(m.matchWildcard("??", "ba"), "wildcard ?? should match haystack ba");
		assertTrue(m.matchWildcard("b*", "ba"), "wildcard b* should match haystack ba");
		assertTrue(m.matchWildcard("?*", "bba"), "wildcard ?* should match haystack bba");
		assertTrue(m.matchWildcard("???", "bba"), "wildcard ??? should match haystack bba");
		assertTrue(m.matchWildcard("?b*", "bbbca"), "wildcard ?b* should match haystack bbbca");
		assertTrue(m.matchWildcard("**b", "bbb"), "wildcard **b should match haystack bbb");
		assertTrue(m.matchWildcard("?*", "bbbb"), "wildcard ?* should match haystack bbbb");
	}

	@Test
	void testWildcardNegative() {
		assertFalse(m.matchWildcard("aaa*", "aaba"), "wildcard aaa* should not match haystack aaba");
		assertFalse(m.matchWildcard("aaaabc?", "bccac"), "wildcard aaaabc? should not match haystack bccac");
		assertFalse(m.matchWildcard("?aaaba*c", "cab"), "wildcard ?aaaba*c should not match haystack cab");
		assertFalse(m.matchWildcard("*a*?abb?", "c"), "wildcard *a*?abb? should not match haystack c");
		assertFalse(m.matchWildcard("ab", "aac"), "wildcard ab should not match haystack aac");
		assertFalse(m.matchWildcard("?ab?*", "b"), "wildcard ?ab?* should not match haystack b");
		assertFalse(m.matchWildcard("a", "bcb"), "wildcard a should not match haystack bcb");
		assertFalse(m.matchWildcard("abcca", "cbccb"), "wildcard abcca should not match haystack cbccb");
		assertFalse(m.matchWildcard("a", "cc"), "wildcard a should not match haystack cc");
		assertFalse(m.matchWildcard("b*?aca*a", "cabb"), "wildcard b*?aca*a should not match haystack cabb");
		assertFalse(m.matchWildcard("??b?ac?", "babb"), "wildcard ??b?ac? should not match haystack babb");
		assertFalse(m.matchWildcard("bac", "cbab"), "wildcard bac should not match haystack cbab");
		assertFalse(m.matchWildcard("??bbc", "cbbab"), "wildcard ??bbc should not match haystack cbbab");
		assertFalse(m.matchWildcard("b?c?a", "aaaab"), "wildcard b?c?a should not match haystack aaaab");
		assertFalse(m.matchWildcard("bcbabc", "babb"), "wildcard bcbabc should not match haystack babb");
		assertFalse(m.matchWildcard("bc?", "bb"), "wildcard bc? should not match haystack bb");
		assertFalse(m.matchWildcard("b*", "cbb"), "wildcard b* should not match haystack cbb");
		assertFalse(m.matchWildcard("bc?c*cc", "babc"), "wildcard bc?c*cc should not match haystack babc");
		assertFalse(m.matchWildcard("ca?**c", "cbbba"), "wildcard ca?**c should not match haystack cbbba");
		assertFalse(m.matchWildcard("cbbabb?a", "ac"), "wildcard cbbabb?a should not match haystack ac");
		assertFalse(m.matchWildcard("cbbbc?", "bbcbb"), "wildcard cbbbc? should not match haystack bbcbb");
		assertFalse(m.matchWildcard("cbb?", "bcbcc"), "wildcard cbb? should not match haystack bcbcc");
		assertFalse(m.matchWildcard("?ccac", "bbac"), "wildcard ?ccac should not match haystack bbac");
		assertFalse(m.matchWildcard("?c*ccc", "bab"), "wildcard ?c*ccc should not match haystack bab");
		assertFalse(m.matchWildcard("c", "ccc"), "wildcard c should not match haystack ccc");
	}

	@Test
	void testMatchFactMapping() {
		assertTrue(m.match(fact1, mapping1));
		assertFalse(m.match(fact1, mapping2));
	}
}
